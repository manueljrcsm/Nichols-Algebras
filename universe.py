import letters as l
import word as w
import element as e
import pbw_element as pe

class Universe:
    """ Class where the data generated by the constructors of FreeAlgebra and PBWAlgebra is stored to be accessed by
    all the internal classes."""

    universe = None
    generators = None
    base_field = None
    q_matrix = None
    pbw_generators = None
    relations = None
    LetterEMPTY = None
    PBWLetterEMPTY = None
    WordEMPTY = None
    ElementZERO = None
    ElementONE = None
    PBWElementZERO = None
    PBWElementONE = None


    @classmethod
    def set_universe(self, algebra) -> None:
        Universe.universe = algebra
        Universe.generators = algebra.generators
        Universe.base_field = algebra.base_field
        Universe.q_matrix = algebra.q_matrix
        
        

    @classmethod
    def set_pbw_universe(self, pbw_algebra) -> None:
        Universe.pbw_universe = pbw_algebra
        Universe.pbw_generators = pbw_algebra.pbw_generators
        Universe.relations = pbw_algebra.relations
        
    @classmethod
    def set_constants(self):
        Universe.LetterEMPTY = l.Letter("", False)
        Universe.WordEMPTY = w.Word([])
        Universe.ElementZERO = e.Element({})
        Universe.ElementONE = e.Element({Universe.WordEMPTY: 1})
        Universe.PBWLetterEMPTY = l.PBWLetter("", Universe.ElementONE, False)
        Universe.PBWElementZERO = pe.PBWElement({})
        Universe.PBWElementONE = pe.PBWElement({Universe.WordEMPTY: 1})
        
        
    
    def type_conversion(inpt , conv_type):
        """
            This function implements a variant of type conversions:
            Between scalars, letters, words and (pbw) elements.
        """
        
    
        
        if type(inpt) == conv_type:
            return inpt
        
        if type(inpt) == l.Letter:
            
            if inpt == Universe.LetterEMPTY and conv_type == l.PBWLetter:
                return Universe.PBWLetterEMPTY
            
            if conv_type == w.Word:
                return w.Word([inpt])
            
            if conv_type == e.Element:
                return (Universe.ElementONE if inpt == Universe.LetterEMPTY else 
                    e.Element({w.Word([inpt]): 1}))
            
            if  inpt == Universe.LetterEMPTY and conv_type == pe.PBWElement:
                return Universe.PBWElementONE
        
            else:
                msg = (" It was not possible to convert ", inpt, " into ", str(conv_type), ".")
                raise AssertionError(msg)
                
        if type(inpt) == l.PBWLetter:
            
            if inpt == Universe.PBWLetterEMPTY and conv_type == l.Letter:
                return Universe.LetterEMPTY
            
            if conv_type == w.Word:
                return w.Word([inpt])
            
            if conv_type == e.Element:
                return (Universe.ElementONE if inpt == Universe.PBWLetterEMPTY else
                        inpt.presentation)
                        
            if  conv_type == pe.PBWElement:
                return pe.PBWElement({w.Word(inpt): 1})
        
            else:
                msg = ("It was not possible to convert ", inpt, " into ", str(conv_type), ".")
                raise AssertionError(msg)
        
        if type(inpt) == w.Word:
            
            if inpt == Universe.WordEMPTY and conv_type in [l.Letter, l.PBWLetter]:
                return Universe.LetterEMPTY if conv_type == l.Letter else Universe.PBWLetterEMPTY
            
            if conv_type == e.Element and all(type(le) == l.Letter for le in inpt.letters):
                return e.Element({inpt: 1})
                        
            if conv_type == e.PBWElement and all(type(le) == l.PBWLetter for le in inpt.letters):
                return pe.PBWElement({inpt: 1})
        
            else:
                msg = ("It was not possible to convert ", inpt, " into ", str(conv_type), ".")
                raise AssertionError(msg)
                
        if type(inpt) == e.Element:
            
            if inpt == Universe.ElementONE and conv_type in [l.Letter, l.PBWLetter, w.Word, pe.PBWElement]:
                return (Universe.LetterEMPTY if conv_type == l.Letter else 
                       (Universe.PBWLetterEMPTY if conv_type == l.PBWLetter else 
                       (Universe.WordEMPTY  if conv_type == w.Word else  
                        Universe.PBWElementONE)))

            else:
                msg = ("It was not possible to convert ", inpt, " into ", str(conv_type), ".")
                raise AssertionError(msg)
                
        if type(inpt) == pe.PBWElement:
            
            if inpt == Universe.PBWElementONE and conv_type in [l.Letter, l.PBWLetter, w.Word, e.Element]:
                return (Universe.LetterEMPTY if conv_type == l.Letter else 
                       (Universe.PBWLetterEMPTY if conv_type == l.PBWLetter else 
                       (Universe.WordEMPTY  if conv_type == w.Word else  
                        Universe.ElementONE)))
            
            else:
                msg = ("It was not possible to convert ", inpt, " into ", str(conv_type), ".")
                raise AssertionError(msg)
       
               
        try:
            return (Universe.ElementONE.scalar_multiply(inpt) if conv_type== e.Element else 
                    Universe.PBWElementONE.scalar_multiply(inpt))
        except:
            msg = ("It was not possible to convert ", inpt, " into an element.")
            raise AssertionError(msg)
            
        
    # Consider importing sage.combinat.q_analogues.q_int outside of Anaconda (running via a SAGE Jupyter Notebook),
    # similar for q_factorial.
"""
def q_int(self, n: int, q):
result = 0
for i in range(n):
result += q**i
return result
 
 
def q_factorial(self, n: int, q):
result = 1
for i in range(n):
result *= self.q_int(i + 1, q)
return result


def q_bilinear(self, first: l.PBWLetter, second: l.PBWLetter):
#TODO

return

"""